import sys
import numpy as np
from scipy.special import betaincinv
import scipy.optimize as op

# R.Leander
# 10-12-2020
# Jackknife estimate of beta parameters from a sample moments.
# Unbiased estimate is approximated by applying the jackknife principle (pseudo-values)
# fitBetaMomentsJack(<sample>,[alpha=...,beta=...,min=...,max=...)
# arguments: sample - numpy array of values (not necessarily sorted), compulsary
#            alpha  - fixed alpha parameter, optional
#            beta   - fixed beta parameter, optional
#            min    - fixed underbound, optional
#            max    - fixed upperbound, optional

def quantilesetbeta(n,alpha,beta,a,b):
    return [qfunbeta(alpha,beta,a,b,(i+1.0-0.3)/(n+0.4)) for i in range(n)]

def quantilesetbeta(n,alpha,beta,a,b):
    pvalues = [(i+1.0-0.3)/(n+0.4) for i in range(n)]
    qvalues = [qfunbeta(alpha,beta,a,b,p) for p in pvalues]
    return pvalues, qvalues


def qfunbeta(alpha,beta,a,b,P):
    return betaincinv(alpha,beta,P)*(b-a)+a

def jackknife(estimator,sample,**kwargs):
    # obtain unbiased estimate using the jackknife approach
    estimate = estimator(sample)
    m = np.size(estimate)
    pseudo = np.array([])
    subsample = np.ma.array(sample)
    nn = len(sample)
    for i in range(nn):
        subsample.mask = False
        subsample.mask[i] = True
        pseudo_estimate = estimator(subsample,**kwargs)
        pseudo = np.append(pseudo, nn*estimate - (nn-1)*pseudo_estimate)
    pseudomean = np.array([])
    pseudovar  = np.array([])
    for j in range(m):
        select = [j+m*i for i in range(nn)]
        pseudomean = np.append(pseudomean, pseudo[select].mean())
        pseudovar  = np.append(pseudovar, pseudo[select].var())
    return pseudomean, pseudovar


def meanVarSkewKurt(sample):
    # return sample Mean, Variance, Skewness and Kurtosis
    s = [0,0,0,0,0]
    for i in range(5):
        s[i] = (sample**i).sum()
    n = s[0]
    mean = s[1]/s[0]
    variance = (s[2]-(s[1]*s[1]/n))/(n-1)
    skewness = (s[3] - 3.*s[1]*s[2]/n + 2*s[1]*s[1]*s[1]/(n*n)) / (variance**(3./2.)*n)
    kurtosis = (s[4] - 4.*s[1]*s[3]/n + 6*s[1]*s[1]*s[2]/(n*n) - 3*s[1]*s[1]*s[1]*s[1]/(n*n*n)) / (variance**2.*n)
    return (mean,variance,skewness,kurtosis)  


def fitBetaMoments(sample,**kwargs):
    alpha_fixed = False
    beta_fixed = False
    a_fixed = False
    b_fixed = False
    if 'alpha' in kwargs:
        p = float(kwargs['alpha'])
    if 'beta' in kwargs:
        q = float(kwargs['beta'])
    if 'a' in kwargs:
        a = float(kwargs['min'])
    if 'b' in kwargs:
        b = float(kwargs['max'])
    
    M1, M2, A3, A4 = meanVarSkewKurt(sample)
    if (alpha_fixed and beta_fixed):
        r = p + q
        print(r, "<----")
    else:
        r = 6 * (A4-A3**2.0-1.0) / (6.0+3*A3**2.0-2*A4)
        if alpha_fixed:
            q = r - p
        elif beta_fixed:
            p = r - q
        else:
            p = r/2.0 * (1.0 - (1.0 - 24.0*(r+1)/(A4*(r+2)*(r+3) - 3*(r+1)*(r-6)))**0.5)
            q = r - p
            if A3>0.0:		# positively skewed
                q,p = max(p,q),min(p,q)
            else:
                p,q = max(p,q),min(p,q)

    if not(a_fixed and b_fixed):
        range = (M2 * r**2.*(r+1)/(p*q))**0.5
        if b_fixed:
            a = b - range
        else:
            if not a_fixed:
                a = M1 - p/r*range
            b = a + range
        return np.array([p,q,a,b])


def fitBetaMomentsJack(sample,**kwargs):
    return jackknife(fitBetaMoments,sample,**kwargs)


def beta_quantiles_residuals(par,**kwargs):
    xs = np.sort(kwargs['qval'])
    fs, xx = quantilesetbeta(len(xs),par[0],par[1],par[2],par[3])
    return xs-xx
    

def fitBetaQuantiles(sample):
    AA = np.min(sample)
    BB = np.max(sample)
    a = 2.0             # start with parabola distribution covering the total interval
    b = 2.0
    est2 = np.array([a,b,AA,BB])
#   op_result = op.least_squares(beta_quantiles_residuals,est2,kwargs={'qval':np.array(sample)})
#   est2 = op_result.x
    est2 = np.array([0,0,0,0])
    return est2


def main():
    # testcode
    betaparstr = sys.argv[1] 	# alpha, beta, a, b
    alpha, beta, a, b = [float(s) for s in sys.argv[1].split()]
    samplesize = int(sys.argv[2])
#   mysample = np.random.beta(alpha,beta,size=samplesize)*(b-a)+a		# random sample for the given parameter
    mysample = np.array(quantilesetbeta(samplesize,alpha,beta,a,b))             # exact quantiles (order statistics) for the given parameters
    est,var = fitBetaMomentsJack(mysample)

    print ("alpha = %15.5e +/- %12.4e" % (est[0],var[0]**0.5))
    print ("beta  = %15.5e +/- %12.4e" % (est[1],var[1]**0.5))
    print ("min   = %15.5e +/- %12.4e" % (est[2],var[2]**0.5))
    print ("max   = %15.5e +/- %12.4e" % (est[3],var[3]**0.5))

if __name__ == '__main__':
    main()

    




    

 

